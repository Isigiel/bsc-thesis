% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Methodology}\label{chapter:methodology}

The goal of this thesis is to evaluate the use of WebAssembly for programming an ESP 32 Microcontroller. After we have introduced the concepts around MCUs and WebAssembly, we would like to explain our approach of measuring the impact of running WebAssembly on MCUs.

\section{Running WebAssembly}

First, as explained earlier, WebAssembly always needs a runtime, which is usually provided by the browser. In this case, we do not need all the features a browser would provide, just a way to execute WASM. Since the momentum around running WASM outside of a browser environment is picking up recently, more and more runtimes become available. A big push for WebAssembly on new platforms came in November of 2019 in the form of the Bytecode Alliance \autocite{noauthor_bytecode_nodate}. An open-source community dedicated to creating the foundations needed to run WASM on multiple platforms in a secure way.

The Bytecode Alliance maintains a couple of different compilers and runtimes for WebAssembly. This project includes the WebAssembly Micro Runtime (WAMR), which is an interpreter based runtime, specifically meant to run on embedded devices such as the ESP32 \autocite{noauthor_bytecodealliancewasm-micro-runtime_2020}. While looking at this project, we noticed that the OS used by the ESP32 (FreeRTOS) was not yet supported, with no current plans to change that.

While a couple of other WebAssembly runtimes are available, \autocite{akinyemi_appcypherawesome-wasm-runtimes_2020} WAMR used to be the only one capable of running on an embedded device. In late 2019 the second runtime for embedded devices was released in WASM3 \autocite{noauthor_wasm3wasm3_2020}. This runtime is the first one we know of to support the ESP32 and FreeRTOS. It also performs significantly better than WAMR in benchmarks \autocite{shymanskyy_wasm3_2020}. Thus we decided that using WASM3 was the way to go about running WASM on the ESP32.

According to the developers' measurements \autocite{shymanskyy_wasm3_2020}, WASM3 is currently the fastest available WebAssembly interpreter, being about 4x slower than current just in time compiling runtimes and about 12x slower than native execution. Because of the strict constraints that embedded devices have, WASM3 uses an interpreter model, which is more memory efficient and provides better startup times than JIT compilation. It also makes portability and security much more comfortable to achieve and maintain.

The speed of WASM3 is impressive, considering that even in browsers, a performance loss of up to 3x can be experienced when comparing WebAssembly to native code execution \autocite{jangda_not_2019}. For our tests, it is crucial to keep in mind that the ESP32 is not a reference platform due to its limited capacities and features.

While the most basic interpreter can be thought of as a loop around a big switch statement that matches all possible instructions in the interpreted code, WASM3 follows a model dubbed M3 \autocite{shymanskyy_wasm3interpreter_2020}. In WASM3, the bytecode first gets compiled into operations for the meta machine, which is traversed by one operation calling the next, which relies on tail-call optimization by the compiler. This leads to an efficient and elegant execution model for their virtual machine.

\section{Comparing the platform}
After finding a way to run WebAssembly on the ESP32 and verifying it with basic tests, we had to find a way to measure how well that works. In order to compare different platforms, a popular tool is benchmarking, in which the same workload is run on multiple platforms to generate values to compare those platforms.

While most benchmarks are meant to provide a comparison of two hardware platforms, in this specific case, we are not interested in the performance of the platform. Instead, we are interested in the performance of different execution models on the same platform, being the default native execution of code explicitly compiled for the ESP32 and the interpreted execution of the WASM code that could run anywhere.

Our desired comparison makes the test setup quite simple, the basic idea is to run the same code on the ESP32 twice, but once compiled to WASM. This approach has worked for the most part, with small detours being made when testing the import of outside functions into WebAssembly. All tests consist of a \lstinline{run} method, which is once called from the main file and once loaded into the engine and run as a WASM function.

In line with how benchmarks work, we set out to design a couple of workloads we could run in both the native and the WebAssembly environments and compare the way they execute. In order to generate meaningful results, we tried to find simple tests that are not too far from what an MCU would execute. Keeping the tests limited and simple also allows us to look at the WASM output and understand the exact instructions in some instances.

\subsection{Specialized Workloads}

The first and most basic test is recursively calculating a Fibonacci number, while extensive recursive calls are not a part of most applications, functions calls in general are. This also shows some WebAssembly specific features since it doe not only have jumps available but allows functions and function calls in the assembler code.

Secondly, switch and if statements are an integral part of any application. So comparing the performance of a switch statement is another indicator of how good applications would perform.

Of course, every application needs memory access, so we decided to implement two memory testsâ€”one using direct access and one using random access to see if there is any impact on performance. Combining memory access and calculation, we also ran a matrix multiplication. This algorithm is the basis for many more complex algorithms, and the tight inner loop offers itself for optimization on the hardware and during compilation.

Of course, it is essential for embedded devices also to have hardware access. Currently, WebAssembly does not have a model of specific hardware features, network stack, or even CPU cores. All this functionality is assumed to be in the browser environment. The runtime we selected offers a mechanic to link external functions that can then be called from the WASM code, so we designed tests to see if outside calls came with a significant overhead that would impact applications using them.

Lastly, we implemented the Fibonacci test again but in AssemblyScript instead of C++. AssemblyScript \autocite{noauthor_assemblyscriptassemblyscript_2020} compiles a subset of TypeScript to WebAssembly. This is exciting for developers with a background in web development, as TypeScript will probably be already familiar to them. We implemented this test to show the new options using WebAssembly opens on the ESP32, which does not natively support a way to run TypeScript. TypeScript itself is an extension of JavaScript that supports strict types.

\section{Running tests}

All tests were run on the ESP-WROOM-32 using the ESP-devkit provided by espressif. The same C++ code was compiled to WebAssembly and also imported into the test program to allow for native execution. Then the test code was run multiple times to generate statistically significant results. The results from these tests will be explained in more detail in a specific section for each test.

\subsection{Testing setup}\label{subsec:testing_setup}

All tests share a very similar main program to execute and time the tests, which we would like to explain now.

\lstinputlisting[language=C++, caption=Main testing method, label=lst:testing_method]{../data/testing_method.cpp}

The primary testing method in listing \ref{lst:testing_method} starts with setting up the WebAssembly runtime, which will be further explained with listing \ref{lst:runtime_setup}. This process is timed to see how much overhead the runtime initialization introduces. Next, there are two arrays set up to hold the test results. Then the test is run for the WASM with the function described in listing \ref{lst:test_exec}, by taking the average time over ten runs and saving that into the previously declared array. Following, the same is done for the native version of the test code. Lastly, the results are printed to the console, and the controller is eventually restarted to rerun the tests.

It is important to note that with this setup, the runtime will be loaded in memory during both tests. Also, the native code is shipped together with the WASM test code. We do not expect interference due to the minimal footprint of both test cases.

\lstinputlisting[language=C++, caption=Runtime setup, label=lst:runtime_setup]{../data/runtime_setup.cpp}

Setting up the runtime is pretty straight forward, initially, the WASM module is imported from a header file, together with its length. Then the environment and runtime are created, followed by parsing the module. If the runtime has to provide functions that the WASM module relies upon, they are linked after loading the module. An example can be found in section \ref{subsec:native} in which lines 24 and 25 of listing \ref{lst:runtime_setup} are not commented out. Once the runtime is fully set up, the function itself is searched for. In our case, the function's name is always "run".

\lstinputlisting[language=C++, caption=WASM execution, label=lst:test_exec]{../data/test_exec.cpp}

The execution of the WASM function is a matter of calling the previously found function with the runtimes \lstinline{m3_CallWithArgs()} method and supplying it with the input arguments. The return value of the operation can be found on the virtual machines stack afterward.

\subsection{Testing matrix multiplication}
To test performance during matrix multiplication, we use the code of listing \ref{lst:matrix_test}. The test function takes one argument, the matrix size. It then creates two n$\times$n matrices and multiplies them. In the end, it returns one value of the resulting matrix. This is to prevent the compiler from optimizing the actual calculation during compilation.

\lstinputlisting[language=C++, caption=Matrix multiply test, label=lst:matrix_test]{../data/test_matrix.cpp}

Running this function in the main program described in section \ref{subsec:testing_setup} results in the Following measurements for the average execution times of 100 runs.

\subsection{Testing memory performance}
Of course, memory performance is an important aspect of any computing platform, so we designed a test to compare it between native and WASM execution.
\lstinputlisting[language=C++, caption=Linear memory test]{../data/test_memory.cpp}
The setup is fairly simple; an array is created and filled with the indices of the respective following elements, imitating a linked list. Then it is read from, starting at index one and saving whatever index was found there into a variable that defines the next index to be read until finally, the next index ends up being 0. Lastly, the next index is returned to prevent compiler optimization.

\subsection{Testing recursive calls}\label{subsec:m_test_recursive}

The test of recursive calls is run by calculating Fibonacci numbers with the following code.

\lstinputlisting[language=C++, caption=Recursive calling test, label=lst:recursive_cpp]{../data/test_recursive.cpp}

\lstinputlisting[language=WebAssembly, caption=WASM code excerpt, label=lst:recursive_wat]{../data/test_recursive.wat}

Listing \ref{lst:recursive_wat} shows the WebAssembly text format generated for the Fibonacci function in listing \ref{lst:recursive_cpp} and we would like to take a closer look at what the WASM module looks like for this specific example. After the module opening, the type of our \lstinline{uint32_t run(uint32_t n)} function is defined and reused in the function definition in line \ref{r-wat:func}, in this line the functions input and return types are also defined. The input is assigned to the \$p0 variable for later use. In line \ref{r-wat:block} the block \lstinline{$B0} is started, it contains the main function body. In line \ref{r-wat:if}, we can see a \lstinline{br_if} instruction; this is a conditional break that breaks the execution of the passed block if the condition is true. The condition, in this case, is the rest of the instructions included in the parentheses. Namely the comparison of the accepted parameter with 2 to see if it is smaller if that is the case the remaining block is skipped and code execution would continue in line \ref{r-wat:end} where the parameter is pushed on the stack, as the topmost value of the stack after the execution is the return value of a WASM function. Alternatively, the execution could continue in line \ref{r-wat:return} with the \lstinline{return} instruction, which executes the instructions inside the parentheses and prevents any further code execution after that, mirroring the common return instruction in C. the Value return is the result of the two recursive calls of line \ref{r-cpp:return2} in the listing \ref{lst:recursive_cpp}. The \lstinline{run} function is called again by using the \lstinline{call} instruction in lines \ref{r-wat:call1} and \ref{r-wat:call2}.

It is important to note that this text format is not strictly WebAssembly, but one version to make it readable for humans. To make it more similar to the look of common programming languages for this listing, code folding was applied. To make the difference visible, listing \ref{lst:recursive_wat-2} shows the WASM code without folding.
\lstinputlisting[language=WebAssembly, caption=WASM code without folding, label=lst:recursive_wat-2]{../data/wat-recursive-2.wat}

\subsection{Testing switch statements}

\lstinputlisting[language=C++, caption=Switch statement test code]{../data/test_switch.cpp}

As previously mentioned, switch statements are a widespread occurrence in software running on microcontrollers and thus a thing to be tested. The test method for this is a big switch statement that is looped over. To prevent optimization, the return value is updated from an array and returned by the function.

\subsection{Testing native calls}\label{subsec:native}

A vital function of the runtime is to expose outside functions to the WASM module and allow the interaction with other libraries from within the WASM code. For this, we designed two reasonably simple tests that call functions not defined in the WASM code.

\lstinputlisting[language=C++, caption=Outside call test code, label=lst:native_test]{../data/test_native.cpp}

As is obvious from listing \ref{lst:native_test}, the test code just calls the outside \lstinline{mark()} function. There is also an import of the test API header in which the external function is defined to make the test code compile.

\lstinputlisting[language=C++, caption=Test api defintiion, label=lst:test_native_api]{../data/test_native_api.cpp}

The resulting WASM code does not include the \lstinline{mark} method, but instead imports it from the \lstinline{thesis} module that is expected to be available at runtime.

\lstinputlisting[language=WebAssembly, caption=WASM code for the outside call, label=lst:test_native_wasm]{../data/test_native.wat}

As displayed in listing \ref{lst:test_native_wasm} line \ref{n-wat:import} the mark function from the thesis module is imported as defined in listing \ref{lst:test_native_api}. The run function then just calls the imported function in line \ref{n-wat:call}.

In order to provide this imported function at runtime, the setup for our tests has to be changed slightly; namely, it has to be linked during the runtime setup in listing \ref{lst:runtime_setup}.

\lstinputlisting[language=C++, caption=Function linking, label=lst:test_native_main]{../data/test_native_main.cpp}

In listing \ref{lst:test_native_main} line \ref{n-wat:global} we introduce a variable to hold a timestamp after the \lstinline{mark} function was called. In line \ref{n-wat:mark_link}, we define the function, which just saves the current timestamp and ends with success. This is then linked into the runtime in line \ref{n-wat:link}. To compare native execution this time, we can not call the exact same function since it was not compiled to WASM at all, so we implement a similar function in line \ref{n-wat:mark_native} that is called during the test of native execution.

\subsection{Running TypeScript}\label{subsec:typeScript}

In listing \ref{lst:test_typeScript} the same function as for \ref{subsec:m_test_recursive} is implemented but in TypeScript instead of C++. This is to explore the new options opened by WebAssembly on the ESP32. The test is then run the same way the other tests work. We are once again comparing the execution performance with the native C++ code.

\lstinputlisting[language=JavaScript, caption=TypeScript testing code, label=lst:test_typeScript]{../data/test_recursive.ts}

The generated WebAssembly code is almost identical as can be seen in listing \ref{lst:recursive_ts_wat}. In line \ref{r-wat:if_block} however \lstinline{if} block is used instead of a conditional branch. That block is closed with the \lstinline{then} statement in line \ref{r-wat:then}. Another difference is the use of the \lstinline{sub} instruction instead of adding a negative number in line \ref{r-wat:sub}. In general though, the genrated WASM code is almost identical.

\lstinputlisting[language=WebAssembly, caption=WASM code excerpt, label=lst:recursive_ts_wat]{../data/test_recursive.ts.wat}

\section{Summary}

In order to assess WebAssembly on the ESP32, we used a new Runtime from late 2019, WASM3. It is only the second runtime meant to run on embedded devices and the first one to date that supports FreeRTOS. It is an interpreter for WebAssembly that follows a meta machine pattern and achieves excellent speeds compared to other WebAssembly runtimes currently available.

Secondly, we designed a collection of workloads that can be used to compare the WebAssembly execution to the native code execution. We modeled the tests after requirements, which applications on an MCU will have. These include function calls, memory access, computation, and the use of outside functions to interact with peripherals, for example. Additionally, we tested the ability of WebAssembly to be a target for new languages, not natively available on the controller, and wrote one test in TypeScript.